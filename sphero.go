package sphero

import (
	"bytes"
	"encoding/binary"
	"fmt"
	serial "github.com/Freeflow/goserial"
	"io"
	"time"
)

func computeChk(data []byte) uint8 {
	sum := 0
	for _, b := range data {
		sum += int(uint8(b))
	}
	chk := (sum % 256) ^ 0xff
	return uint8(chk)
}

type Config struct {
	Bluetooth serial.Config
}

type Sphero struct {
	// Current Sphero configuration
	conf *Config

	// Connection to the underlying Bluetooth serial port
	conn io.ReadWriteCloser

	// Sequence number to associate with responses
	seq uint8

	// Map of response channels to sequence numbers
	res map[uint8]chan<- *Response

	// Channel used to signal that the listen goroutine should stop
	kill chan bool

	// Async response channel
	async chan<- interface{}
}

func NewSphero(conf *Config, async chan<- interface{}) (*Sphero, error) {
	var conn io.ReadWriteCloser
	var err error
	if conn, err = serial.OpenPort(&conf.Bluetooth); err != nil {
		return nil, err
	}

	s := &Sphero{
		conf:  conf,
		conn:  conn,
		seq:   0,
		res:   make(map[uint8]chan<- *Response),
		kill:  make(chan bool, 1),
		async: async,
	}

	go s.listen()

	return s, nil
}

type Response struct {
	// Start of Packet #1 - Always FFh
	sop1,

	// Start of Packet #2 - Set to FFh when this is an acknowledgement,
	// FEh when this is an asynchronous message
	sop2,

	// Message Response - This is generated by the message decoder of the
	// virtual device (refer to the appropriate appendix for a list of values)
	mrsp,

	// Sequence Number - Echoed to the client when this is a direct message
	// response (set to 00h when SOP2 = FEh)
	seq,

	// Data Length - The number of bytes following through the end of the packet
	dlen,

	// Data - Optional data in response to the Command or based on "streaming"
	// data settings
	data,

	// Checksum - Packet checksum (as computed above)
	chk []byte
}

func (s *Sphero) parse(buf []byte) (n int, err error) {
	if len(buf) < 2 {
		return
	}

	sop1 := buf[0]

	if sop1 != SOP1 {
		err = fmt.Errorf("SOP1 must be FFh but got %p", sop1)
		return
	}

	sop2 := buf[1]

	switch sop2 {
	case SOP2_ANSWER:
		if len(buf) < 6 {
			fmt.Println("Answer buffer too short, waiting for more", buf)
			return
		}

		// TODO: All of these buffer reads are ugly and terrible
		dlenBuf := bytes.NewBuffer([]byte{buf[4]})
		var dlen uint8
		binary.Read(dlenBuf, binary.BigEndian, &dlen)

		if len(buf) < int(dlen)+5 {
			fmt.Println("Buffer shorter than expected length")
			return
		}

		mrspBuf := bytes.NewBuffer([]byte{buf[2]})
		var mrsp uint8
		binary.Read(mrspBuf, binary.BigEndian, &mrsp)

		seqBuf := bytes.NewBuffer([]byte{buf[3]})
		var seq uint8
		binary.Read(seqBuf, binary.BigEndian, &seq)

		dataEnd := 5 + (dlen - 1)
		data := buf[5:dataEnd]

		// Calculate the chk
		chkSlice := buf[2:dataEnd]
		compChk := computeChk(chkSlice)

		chkBuf := bytes.NewBuffer([]byte{buf[dataEnd]})
		var chk uint8
		binary.Read(chkBuf, binary.BigEndian, &chk)

		if compChk != chk {
			err = fmt.Errorf("Invalid check, expected %#x, got %#x", chk, compChk, buf[2:dataEnd])
			return
		}

		r := &Response{[]byte{sop1}, []byte{sop2}, []byte{mrsp}, []byte{seq}, []byte{dlen}, data, []byte{chk}}
		if res, ok := s.res[seq]; ok {
			res <- r
		}
		n = int(dataEnd) + 1
	case SOP2_ASYNC:
		if len(buf) < 7 {
			fmt.Println("Async buffer too short, waiting for more", buf)
		}
		n = 1
		/* ID_CODE = buffer[2]
		   dlen = buffer.readUInt16BE(3)
		   if buffer.length < dlen + 5 {
		     return
		   }
		   startOfData = 5
		   dataEnd = startOfData + (dlen - 1)
		   endOfPacket = endOfData + 1
		   DATA = buffer.slice(startOfData, endOfData)
		   // msg = SOP2: SOP2, ID_CODE: ID_CODE, DATA: DATA
		   r := &AsyncResponse{[]byte{sop1}, []byte{sop2}, []byte{id}, []byte{data}}
		   s.async <- r
		   n = int(dataEnd) + 1
		 } */
	default:
		err = fmt.Errorf("Unexpected SOP2, should be %#x or %#x but got %#x", SOP2_ANSWER, SOP2_ASYNC, sop2)
		n = 1 // Chomp 1 byte and maybe we'll recover
	}
	return
}

func (s *Sphero) listen() {
	var data []byte
	var buf []byte
	var err error
	var n int

	for {
		select {
		case <-s.kill:
			fmt.Println("Killing goroutine")
			return
		default:
			// Read data from the Sphero
			data = make([]byte, 256)
			if n, err = s.Read(data); err != nil {
				fmt.Println("Read:", err)
				return
			}

			// We didn't receive any data
			if n == 0 {
				continue
			}

			data = data[:n]

			// Append the new data to our buffer
			buf = append(buf, data...)

			// Attempt to parse the buf
			if n, err = s.parse(buf); err != nil {
				fmt.Println("Parse:", err)
			}

			// We successfully parsed data, trim our buffer
			if n > 0 {
				buf = buf[n:]
			}
		}
	}
}

// Implement io.ReadWriteCloser

// Implement io.Closer
func (s *Sphero) Close() error {
	s.kill <- true // Kill our goroutine
	return s.conn.Close()
}

// Implement io.Writer
func (s *Sphero) Write(data []byte) (int, error) {
	return s.conn.Write(data)
}

// Implement io.Reader
func (s *Sphero) Read(data []byte) (int, error) {
	return s.conn.Read(data)
}

func (s *Sphero) Send(did, cid uint8, data []byte, res chan<- *Response) error {
	s.seq++
	s.res[s.seq] = res

	var buf bytes.Buffer
	buf.Write([]byte{SOP1})                                  // SOP1
	buf.Write([]byte{SOP2_ANSWER})                           // SOP2
	buf.Write([]byte{did})                                   // DID
	buf.Write([]byte{cid})                                   // CID
	binary.Write(&buf, binary.BigEndian, s.seq)              // SEQ
	binary.Write(&buf, binary.BigEndian, uint8(len(data)+1)) // DLEN
	buf.Write(data)                                          // <data>

	chk := computeChk(buf.Bytes()[2:buf.Len()])
	binary.Write(&buf, binary.BigEndian, chk) // DLEN

	fmt.Printf("Writing %#x\n", buf.Bytes())

	_, err := s.Write(buf.Bytes())
	return err
}

func (s *Sphero) Sleep(wakeup time.Duration, macro uint8, orbBasic uint16, res chan<- *Response) error {
	var data bytes.Buffer
	binary.Write(&data, binary.BigEndian, uint16(wakeup))
	binary.Write(&data, binary.BigEndian, macro)
	binary.Write(&data, binary.BigEndian, orbBasic)
	return s.Send(DID_CORE, CMD_SLEEP, data.Bytes(), res)
}

func (s *Sphero) Ping(res chan<- *Response) error {
	return s.Send(DID_CORE, CMD_PING, []byte{}, res)
}

func (s *Sphero) SetRGBLEDOutput() error {
	return s.Send(DID_CORE, CMD_PING, []byte{}, res)
}

func (s *Sphero) SetBackLEDOutput() error {
	return s.Send(DID_CORE, CMD_PING, []byte{}, res)
}

func (s *Sphero) GetRGBLED() error {
	return s.Send(DID_CORE, CMD_PING, []byte{}, res)
}
